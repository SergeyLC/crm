import React from 'react';
import { screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { render } from '@/__tests__/test-utils';

import { LeadEditDialog } from '../LeadEditDialog';
import { useGetLeadByIdQuery, useUpdateLeadMutation, useCreateLeadMutation } from '@/entities/lead';

// Mock dependencies
jest.mock('@/entities/lead', () => ({
  useGetLeadByIdQuery: jest.fn(),
  useUpdateLeadMutation: jest.fn(),
  useCreateLeadMutation: jest.fn(),
}));

jest.mock('@/shared/lib/auth', () => ({
  useAuth: jest.fn(),
}));

interface MockFormData {
  title?: string;
  productInterest?: string;
  potentialValue?: number;
  [key: string]: unknown;
}

jest.mock('@/features/form/ui/BaseUpsertFields', () => ({
  BaseUpsertFields: ({ initialData, onChange }: { 
    initialData?: MockFormData; 
    onChange?: (data: MockFormData) => void 
  }) => (
    <div data-testid="base-upsert-fields">
      <input
        data-testid="title-input"
        placeholder="Title"
        defaultValue={initialData?.title || ''}
        onChange={(e) => onChange?.({ ...initialData, title: e.target.value })}
      />
      <input
        data-testid="product-input"
        placeholder="Product"
        defaultValue={initialData?.productInterest || ''}
        onChange={(e) => onChange?.({ ...initialData, productInterest: e.target.value })}
      />
      <input
        data-testid="potential-value-input"
        placeholder="Potential Value"
        type="number"
        defaultValue={initialData?.potentialValue || ''}
        onChange={(e) => onChange?.({ ...initialData, potentialValue: Number(e.target.value) })}
      />
    </div>
  ),
}));

jest.mock('@/entities/appointment/lib/sanitizers', () => ({
  sanitizeAppointments: jest.fn((appointments) => appointments),
}));

const testMockUser = {
  id: 'user-1',
  name: 'Test User',
  email: 'test@example.com',
};

const testMockLeadData = {
  id: 'lead-1',
  title: 'Test Lead',
  productInterest: 'Product A',
  potentialValue: 1000,
  assigneeId: 'user-1',
  stage: 'LEAD' as const,
};

describe('LeadEditDialog', () => {
  const mockOnClose = jest.fn();
  const mockInvalidateQueries = jest.fn();
  const mockMutateAsync = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();

    // Mock useAuth
    const mockUseAuth = require('@/shared/lib/auth').useAuth as jest.Mock;
    mockUseAuth.mockReturnValue({
      user: testMockUser,
      isAuthenticated: true,
    });

    // Mock mutations
    (useCreateLeadMutation as jest.Mock).mockReturnValue({
      mutateAsync: mockMutateAsync,
      isPending: false,
    });

    (useUpdateLeadMutation as jest.Mock).mockReturnValue({
      mutateAsync: mockMutateAsync,
      isPending: false,
    });

    // Mock QueryClient
    jest.doMock('@tanstack/react-query', () => ({
      ...jest.requireActual('@tanstack/react-query'),
      useQueryClient: () => ({
        invalidateQueries: mockInvalidateQueries,
      }),
    }));
  });

  describe('Create Lead', () => {
    beforeEach(() => {
      (useGetLeadByIdQuery as jest.Mock).mockReturnValue({
        data: undefined,
        isLoading: false,
      });
    });

    it('should render create dialog correctly', () => {
      render(
        <LeadEditDialog
          open={true}
          onClose={mockOnClose}
        />
      );

      expect(screen.getByText('dialog.create')).toBeInTheDocument();
      expect(screen.getByText('dialog.cancel')).toBeInTheDocument();
      expect(screen.getByTestId('base-upsert-fields')).toBeInTheDocument();
    });

    it('should create lead successfully', async () => {
      const user = userEvent.setup();
      mockMutateAsync.mockResolvedValueOnce({});

      render(
        <LeadEditDialog
          open={true}
          onClose={mockOnClose}
          invalidateKeys={[['leads']]}
        />
      );

      // Fill form data
      const titleInput = screen.getByTestId('title-input');
      const productInput = screen.getByTestId('product-input');

      await user.type(titleInput, 'New Lead');
      await user.type(productInput, 'Product B');

      // Submit form
      const createButton = screen.getAllByText('dialog.create')[1]; // Get submit button
      await user.click(createButton);

      await waitFor(() => {
        expect(mockMutateAsync).toHaveBeenCalledWith(
          expect.objectContaining({
            title: 'New Lead',
            productInterest: 'Product B',
          })
        );
      });

      expect(mockOnClose).toHaveBeenCalled();
    });

    it('should handle create error gracefully', async () => {
      const user = userEvent.setup();
      const consoleError = jest.spyOn(console, 'error').mockImplementation(() => {});
      mockMutateAsync.mockRejectedValueOnce(new Error('Create failed'));

      render(
        <LeadEditDialog
          open={true}
          onClose={mockOnClose}
        />
      );

      const createButton = screen.getAllByText('dialog.create')[1];
      await user.click(createButton);

      await waitFor(() => {
        expect(mockMutateAsync).toHaveBeenCalled();
      });

      // Dialog should not close on error
      expect(mockOnClose).not.toHaveBeenCalled();
      
      consoleError.mockRestore();
    });
  });

  describe('Update Lead', () => {
    beforeEach(() => {
      (useGetLeadByIdQuery as jest.Mock).mockReturnValue({
        data: testMockLeadData,
        isLoading: false,
      });
    });

    it('should render update dialog correctly', () => {
      render(
        <LeadEditDialog
          id="lead-1"
          open={true}
          onClose={mockOnClose}
        />
      );

      expect(screen.getByText('dialog.edit')).toBeInTheDocument();
      expect(screen.getByText('dialog.cancel')).toBeInTheDocument();
      expect(screen.getByText('dialog.update')).toBeInTheDocument();
      expect(screen.getByTestId('base-upsert-fields')).toBeInTheDocument();
    });

    it('should show loading state when fetching lead data', () => {
      (useGetLeadByIdQuery as jest.Mock).mockReturnValue({
        data: undefined,
        isLoading: true,
      });

      render(
        <LeadEditDialog
          id="lead-1"
          open={true}
          onClose={mockOnClose}
        />
      );

      expect(screen.getByRole('progressbar')).toBeInTheDocument();
    });

    it('should update lead successfully', async () => {
      const user = userEvent.setup();
      mockMutateAsync.mockResolvedValueOnce({});

      render(
        <LeadEditDialog
          id="lead-1"
          open={true}
          onClose={mockOnClose}
          invalidateKeys={[['leads'], ['lead', 'lead-1']]}
        />
      );

      // Modify form data
      const titleInput = screen.getByTestId('title-input');
      await user.clear(titleInput);
      await user.type(titleInput, 'Updated Lead');

      // Submit form
      const updateButton = screen.getByText('dialog.update');
      await user.click(updateButton);

      await waitFor(() => {
        expect(mockMutateAsync).toHaveBeenCalledWith({
          id: 'lead-1',
          body: expect.objectContaining({
            title: 'Updated Lead',
          }),
        });
      });

      expect(mockOnClose).toHaveBeenCalled();
    });
  });

  describe('Dialog behavior', () => {
    beforeEach(() => {
      (useGetLeadByIdQuery as jest.Mock).mockReturnValue({
        data: undefined,
        isLoading: false,
      });
    });

    it('should not render when closed', () => {
      render(
        <LeadEditDialog
          open={false}
          onClose={mockOnClose}
        />
      );

      expect(screen.queryByText('dialog.create')).not.toBeInTheDocument();
    });

    it('should close dialog when cancel is clicked', async () => {
      const user = userEvent.setup();

      render(
        <LeadEditDialog
          open={true}
          onClose={mockOnClose}
        />
      );

      const cancelButton = screen.getByText('dialog.cancel');
      await user.click(cancelButton);

      expect(mockOnClose).toHaveBeenCalled();
    });

    it('should close dialog when close icon is clicked', async () => {
      const user = userEvent.setup();

      render(
        <LeadEditDialog
          open={true}
          onClose={mockOnClose}
        />
      );

      const closeButton = screen.getByLabelText('close');
      await user.click(closeButton);

      expect(mockOnClose).toHaveBeenCalled();
    });
  });
});
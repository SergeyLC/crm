#!/usr/bin/env node
const fs = require('fs');
const path = require('path');

const root = path.resolve(__dirname, '..');
const srcDir = path.join(root, 'src');
const outDir = path.join(root, 'src', 'locales', 'collected');
const generatedFile = path.join(root, 'src', 'locales', 'generated_i18n.ts');

function ensureDir(p) {
  if (!fs.existsSync(p)) fs.mkdirSync(p, { recursive: true });
}

function isLocalesFolder(dir) {
  return path.basename(dir) === 'locales';
}

function findLocaleFiles(dir, results = []) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const e of entries) {
    const full = path.join(dir, e.name);
    if (e.isDirectory()) {
      if (isLocalesFolder(full)) {
        const files = fs.readdirSync(full).filter(f => f.endsWith('.json'));
        for (const f of files) results.push(path.join(full, f));
      } else {
        findLocaleFiles(full, results);
      }
    }
  }
  return results;
}

function deepMerge(target, source) {
  for (const key of Object.keys(source)) {
    if (
      source[key] && typeof source[key] === 'object' &&
      !Array.isArray(source[key]) &&
      target[key] && typeof target[key] === 'object' &&
      !Array.isArray(target[key])
    ) {
      deepMerge(target[key], source[key]);
    } else {
      target[key] = source[key];
    }
  }
}

function inferNamespace(filePath) {
  // Determine namespace based on file name and location.
  // If filename is a language file (e.g. en.json), infer namespace from ancestor feature/shared folder.
  const filename = path.basename(filePath);
  const parts = filePath.split(path.sep);
  const langFileMatch = /^[a-z]{2}(?:-[A-Z]{2})?\.json$/;
  if (langFileMatch.test(filename)) {
    const idx = parts.indexOf('features');
    if (idx >= 0 && parts.length > idx + 1) return parts[idx + 1];
    // otherwise use the parent folder of the 'locales' dir
    const dir = path.dirname(filePath); // .../locales
    const maybe = path.basename(path.dirname(dir)); // parent of locales
    return maybe || 'shared';
  }

  // If filename itself encodes the namespace (e.g. group.json), use that.
  return path.basename(filePath, '.json');
}

function run() {
  console.log('Collecting component-local locales...');
  const files = findLocaleFiles(srcDir);
  if (!files.length) {
    console.log('No component-local locale files found.');
    return;
  }
  // Prepare structure: lang -> ns -> [filePaths]
  const map = {};
  for (const file of files) {
    try {
      const lang = path.basename(file, '.json');
      const ns = inferNamespace(file);
      map[lang] = map[lang] || {};
      map[lang][ns] = map[lang][ns] || [];
      map[lang][ns].push(file);
    } catch (err) {
      console.error('Failed to process', file, err.message);
    }
  }

  // Generate TypeScript file with imports and an exported object
  ensureDir(path.dirname(generatedFile));
  const imports = [];
  const compositeStatements = [];
  const exportLines = [];

  // helper to create safe variable names
  function safeVar(name) {
    return name.replace(/[^a-zA-Z0-9_]/g, '_').replace(/^([0-9])/, '_$1');
  }

  let importIndex = 0;
  for (const lang of Object.keys(map)) {
    for (const ns of Object.keys(map[lang])) {
      const list = map[lang][ns];
      const varNames = [];
      for (const f of list) {
        importIndex += 1;
        const rel = './' + path.relative(path.join(root, 'src', 'locales'), f).replace(/\\/g, '/');
        const v = safeVar(`${ns}_${lang}_${importIndex}`);
        imports.push(`import ${v} from '${rel}';`);
        varNames.push(v);
      }
      const alias = safeVar(`${ns}_${lang}`);
      if (varNames.length === 1) {
        compositeStatements.push(`const ${alias} = ${varNames[0]};`);
      } else {
        compositeStatements.push(`const ${alias} = Object.assign({}, ${varNames.join(', ')});`);
      }
      exportLines.push({ lang, ns, alias });
    }
  }

  const header = `// THIS FILE IS AUTO-GENERATED BY scripts/collect-locales.js
/* eslint-disable */
// Generated imports for component-local i18n JSON files
`;

  let out = header + '\n';
  out += imports.join('\n') + '\n\n';
  out += compositeStatements.join('\n') + '\n\n';

  // Build export object
  const grouped = {};
  for (const e of exportLines) {
    grouped[e.lang] = grouped[e.lang] || {};
    grouped[e.lang][e.ns] = e.alias;
  }
  out += 'export const generatedI18n: Record<string, Record<string, any>> = {' + '\n';
  for (const lang of Object.keys(grouped)) {
    out += `  '${lang}': {\n`;
    for (const ns of Object.keys(grouped[lang])) {
      out += `    '${ns}': ${grouped[lang][ns]},\n`;
    }
    out += '  },\n';
  }
  out += '};\n\nexport default generatedI18n;\n';

  // Create namespace list: prefer canonical order, then extras
  const canonical = ["common","app","auth","shared","deal","appointment","lead","user","kanban","group"];
  const foundNs = new Set();
  for (const lang of Object.keys(grouped)) {
    for (const ns of Object.keys(grouped[lang])) foundNs.add(ns);
  }
  const extras = Array.from(foundNs).filter(n => !canonical.includes(n)).sort();
  const presentCanonical = canonical.filter(n => foundNs.has(n));
  const finalNs = presentCanonical.concat(extras);
  out += `export const generatedNS = ${JSON.stringify(finalNs, null, 2)};\n`;

  fs.writeFileSync(generatedFile, out, 'utf8');
  console.log(`Wrote ${path.relative(root, generatedFile)}`);
}

run();
